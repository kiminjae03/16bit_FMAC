#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>
#include "../Common/DataType.h"
#include "bitconv.h"

#if defined(SoundFloat24)
#define OPDebug

unsigned int MUL_13x21(unsigned int cand, unsigned int ier) {

	int a;
	__int64 product;
	product = (__int64)cand * ier;
	a = (product >> 15) & 0x1FFFF;
	return a;
}

//unsigned int MUL_17x13(unsigned int cand, unsigned int ier) {
unsigned int MUL_18x13(unsigned int cand, unsigned int ier) {

	int a, product;
	product = cand * ier;
	a = (product >> 10);
	return a;
}


//unsigned int MUL_17x10(unsigned int cand, unsigned int ier) {
unsigned int MUL_18x10(unsigned int cand, unsigned int ier) {

	int a, yh, yh_yl, ext, yl, product;

	yh = ((cand >> 11) & 0x7F) << 11;
	yl = (~cand) & 0x7FF;
	//yl = (-(int)cand) & 0x7FF;
	yh_yl = yh + yl;
	ext = ier;

	product = yh_yl * ext;
	//a = product >> 14;
	a = product >> 15;
	return a;
}

unsigned int BIT_INV_21B(unsigned int ain) {

	unsigned int aout;
	aout = (0 - ain) & 0x1FFFFF;
	return aout;
}

unsigned int DLUT(unsigned int addr) {

	int LUTMEM[64] = { 0x7e0,0x7a3,0x768,0x731,0x6fb,0x6c8,0x697,0x668,
						0x63b,0x610,0x5e7,0x5bf,0x599,0x574,0x551,0x52f,
						0x50e,0x4ee,0x4d0,0x4b3,0x496,0x47b,0x461,0x447,
						0x42f,0x417,0x400,0x3e9,0x3d4,0x3bf,0x3ab,0x397,
						0x384,0x372,0x360,0x34f,0x33e,0x32e,0x31e,0x30f,
						0x300,0x2f1,0x2e3,0x2d5,0x2c8,0x2bb,0x2af,0x2a2,
						0x296,0x28b,0x27f,0x274,0x26a,0x25f,0x255,0x24b,
						0x241,0x238,0x22f,0x225,0x21d,0x214,0x20c,0x204 };
	/*0x3f0,0x3d1,0x3b4,0x398,0x37d,0x364,0x34b,0x334,
	0x31d,0x308,0x2f3,0x2df,0x2cc,0x2ba,0x2a8,0x297,
	0x287,0x277,0x268,0x259,0x24b,0x23d,0x230,0x223,
	0x217,0x20b,0x200,0x1f4,0x1ea,0x1df,0x1d5,0x1cb,
	0x1c2,0x1b9,0x1b0,0x1a7,0x19f,0x197,0x18f,0x187,
	0x180,0x178,0x171,0x16a,0x164,0x15d,0x157,0x151,
	0x14b,0x145,0x13f,0x13a,0x135,0x12f,0x12a,0x125,
	0x120,0x11c,0x117,0x112,0x10e,0x10a,0x106,0x102 };*/

	return LUTMEM[addr];
}



unsigned int FInv(unsigned int y) {

	int s, q, one_over_yh2, a, ay, inv_ay, q_temp;
	int exp1, exp4, underflow;
	unsigned int out;

	s = (y >> 23);

	one_over_yh2 = DLUT((y >> 11) & 0x3F);

	a = MUL_18x10(((y & 0x1FFFF) | 0x20000), one_over_yh2);

	exp1 = 62 - ((y >> 17) & 0x3F);

	if (exp1 < 0) underflow = 1;
	else underflow = 0;


	ay = MUL_18x13(((y & 0x1FFFF) | 0x20000), a);

	inv_ay = BIT_INV_21B(ay);

	q_temp = MUL_13x21(a, inv_ay);
	if ((y & 0x1ffff) == 0) {
		q_temp = 0;
		exp4 = exp1;
	}
	else {
		exp4 = (exp1 - 1) & 0x7F;
	}


	if (underflow || exp4 == 0)
		q = 0;
	else if ((exp4 & 0x40) == 0x40)
		q = 0;
	else if ((y & 0x7e0000) == 0)
		q = 0x7fffff;
	else q = ((exp4 & 0x3F) << 17) | (q_temp);




	out = (s << 23) | q;
#ifdef OPDebug
	{
		float fy, fout;
		int outtemp;
		//if (q == 0)
		//	out = 0;
		fy = f24f32(y);
		fout = 1.0f / fy;
		outtemp = (int)x_f32f24(fout) - out;
		if (outtemp > 1 || outtemp < -1)
			printf("FInvError : input - %x output -%x\n", y, out);

	}
#endif
	return out;


}


// Sign : 1, Exponent : 6, Mantissa : 17, Total : 24 bit
unsigned int Fmul(unsigned int x, unsigned int y) {

	int sign_x, sign_y, exp_x, exp_y, frac_x, frac_y, sign_compute;
	__int64 frac_multiply;
	int frac_compute, exp_add;
	int underflow, exp_compute, overflow, out, one_zero;

	sign_x = (x >> 23);
	exp_x = (x >> 17) & 0x3F;
	frac_x = x & 0x1FFFF;

	sign_y = (y >> 23);
	exp_y = (y >> 17) & 0x3F;
	frac_y = y & 0x1FFFF;
	if (exp_x == 0 || exp_y == 0)one_zero = 1;
	else one_zero = 0;

	sign_compute = sign_x ^ sign_y;

	frac_multiply = (__int64)(frac_x | 0x20000) * (frac_y | 0x20000);

	if (((frac_multiply >> 35))) {
		frac_compute = (frac_multiply >> 18) & 0x1FFFF;
		exp_add = 1;
	}
	else {
		frac_compute = (frac_multiply >> 17) & 0x1FFFF;
		exp_add = 0;
	}

	exp_compute = (exp_x + exp_y) + exp_add - 31;

	if ((exp_compute & 0x80) || (exp_compute == 0))
		underflow = 1;
	else underflow = 0;


	if (exp_compute & 0x40)
		overflow = 1;
	else overflow = 0;

	if (one_zero)
		out = 0;
	else if (underflow)
		out = 0;
	else if (overflow)
		out = (sign_compute << 23) | 0x7FFFFF;
	else
		out = (sign_compute << 23) | (exp_compute << 17) | frac_compute;

#ifdef OPDebug
	{
		float fx, fy, fout;
		int outtemp;
		fx = f24f32(x);
		fy = f24f32(y);
		fout = fx * fy;
		outtemp = (int)x_f32f24(fout) - out;
		if (outtemp > 1 || outtemp < -1)
			printf(" FmulError : x = %x, y=%x out=%x\n", x, y, out);

	}
#endif
	return out;
}


////////////sqrt//////////////////
int SQRTALUT[256] = {
	0x0D280, 0x0D000, 0x0CD00, 0x0CA80, 0x0C780, 0x0C500, 0x0C280, 0x0C000, 0x0BD00, 0x0BA80, 0x0B800, 0x0B580, 0x0B300, 0x0B080, 0x0AE80, 0x0AC00,
	0x0A980, 0x0A700, 0x0A500, 0x0A280, 0x0A000, 0x09E00, 0x09C00, 0x09980, 0x09780, 0x09500, 0x09300, 0x09100, 0x08F00, 0x08D00, 0x08A80, 0x08880,
	0x08680, 0x08480, 0x08280, 0x08080, 0x07E80, 0x07D00, 0x07B00, 0x07900, 0x07700, 0x07500, 0x07380, 0x07180, 0x06F80, 0x06E00, 0x06C00, 0x06A80,
	0x06880, 0x06700, 0x06500, 0x06380, 0x06200, 0x06000, 0x05E80, 0x05D00, 0x05B00, 0x05980, 0x05800, 0x05680, 0x05480, 0x05300, 0x05180, 0x05000,
	0x04E80, 0x04D00, 0x04B80, 0x04A00, 0x04880, 0x04700, 0x04580, 0x04400, 0x04280, 0x04100, 0x03F80, 0x03E80, 0x03D00, 0x03B80, 0x03A00, 0x03880,
	0x03780, 0x03600, 0x03480, 0x03380, 0x03200, 0x03080, 0x02F80, 0x02E00, 0x02D00, 0x02B80, 0x02A00, 0x02900, 0x02780, 0x02680, 0x02500, 0x02400,
	0x02280, 0x02180, 0x02080, 0x01F00, 0x01E00, 0x01D00, 0x01B80, 0x01A80, 0x01980, 0x01800, 0x01700, 0x01600, 0x01480, 0x01380, 0x01280, 0x01180,
	0x01000, 0x00F00, 0x00E00, 0x00D00, 0x00C00, 0x00B00, 0x00A00, 0x00880, 0x00780, 0x00680, 0x00580, 0x00480, 0x00380, 0x00280, 0x00180, 0x00080,
	0x1FE00, 0x1FA00, 0x1F600, 0x1F280, 0x1EE80, 0x1EA80, 0x1E700, 0x1E380, 0x1DF80, 0x1DC00, 0x1D880, 0x1D500, 0x1D180, 0x1CE00, 0x1CA80, 0x1C700,
	0x1C400, 0x1C080, 0x1BD00, 0x1BA00, 0x1B680, 0x1B380, 0x1B080, 0x1AD80, 0x1AA00, 0x1A700, 0x1A400, 0x1A100, 0x19E00, 0x19B00, 0x19800, 0x19580,
	0x19280, 0x18F80, 0x18D00, 0x18A00, 0x18780, 0x18480, 0x18200, 0x17F00, 0x17C80, 0x17A00, 0x17780, 0x17480, 0x17200, 0x16F80, 0x16D00, 0x16A80,
	0x16800, 0x16580, 0x16300, 0x16080, 0x15E80, 0x15C00, 0x15980, 0x15780, 0x15500, 0x15280, 0x15080, 0x14E00, 0x14C00, 0x14980, 0x14780, 0x14500,
	0x14300, 0x14100, 0x13E80, 0x13C80, 0x13A80, 0x13880, 0x13680, 0x13400, 0x13200, 0x13000, 0x12E00, 0x12C00, 0x12A00, 0x12800, 0x12600, 0x12480,
	0x12280, 0x12080, 0x11E80, 0x11C80, 0x11A80, 0x11900, 0x11700, 0x11500, 0x11380, 0x11180, 0x11000, 0x10E00, 0x10C00, 0x10A80, 0x10880, 0x10700,
	0x10500, 0x10380, 0x10200, 0x10000, 0x0FE80, 0x0FD00, 0x0FB00, 0x0F980, 0x0F800, 0x0F600, 0x0F480, 0x0F300, 0x0F180, 0x0F000, 0x0EE00, 0x0EC80,
	0x0EB00, 0x0E980, 0x0E800, 0x0E680, 0x0E500, 0x0E380, 0x0E200, 0x0E080, 0x0DF00, 0x0DD80, 0x0DC00, 0x0DA80, 0x0D900, 0x0D780, 0x0D600, 0x0D500

};
int SQRTYLUT[256] = {
	0x1A828, 0x1ADCD, 0x1B36D, 0x1B907, 0x1BE9C, 0x1C42B, 0x1C9B5, 0x1CF3A, 0x1D4B9, 0x1DA34, 0x1DFA9, 0x1E519, 0x1EA84, 0x1EFEA, 0x1F54C, 0x1FAA8,
	0x20000, 0x20553, 0x20AA1, 0x20FEB, 0x21530, 0x21A70, 0x21FAC, 0x224E4, 0x22A17, 0x22F46, 0x23470, 0x23996, 0x23EB8, 0x243D6, 0x248EF, 0x24E05,
	0x25316, 0x25823, 0x25D2D, 0x26232, 0x26733, 0x26C31, 0x2712A, 0x27620, 0x27B12, 0x28000, 0x284EA, 0x289D1, 0x28EB4, 0x29394, 0x29870, 0x29D48,
	0x2A21D, 0x2A6EE, 0x2ABBC, 0x2B086, 0x2B54D, 0x2BA10, 0x2BED1, 0x2C38D, 0x2C847, 0x2CCFD, 0x2D1B0, 0x2D660, 0x2DB0C, 0x2DFB6, 0x2E45C, 0x2E8FF,
	0x2ED9F, 0x2F23C, 0x2F6D5, 0x2FB6C, 0x30000, 0x30491, 0x3091F, 0x30DAA, 0x31232, 0x316B7, 0x31B39, 0x31FB8, 0x32435, 0x328AE, 0x32D25, 0x33199,
	0x3360B, 0x33A79, 0x33EE5, 0x3434F, 0x347B5, 0x34C19, 0x3507B, 0x354D9, 0x35935, 0x35D8F, 0x361E6, 0x3663A, 0x36A8C, 0x36EDB, 0x37328, 0x37773,
	0x37BBB, 0x38000, 0x38443, 0x38884, 0x38CC2, 0x390FE, 0x39537, 0x3996E, 0x39DA3, 0x3A1D6, 0x3A606, 0x3AA34, 0x3AE60, 0x3B289, 0x3B6B0, 0x3BAD5,
	0x3BEF8, 0x3C318, 0x3C736, 0x3CB53, 0x3CF6D, 0x3D384, 0x3D79A, 0x3DBAE, 0x3DFBF, 0x3E3CE, 0x3E7DC, 0x3EBE7, 0x3EFF0, 0x3F3F7, 0x3F7FC, 0x3FBFF,
	0x00000, 0x003FE, 0x007F8, 0x00BEE, 0x00FE1, 0x013CF, 0x017BA, 0x01BA1, 0x01F84, 0x02363, 0x0273F, 0x02B18, 0x02EED, 0x032BE, 0x0368C, 0x03A57,
	0x03E1E, 0x041E1, 0x045A2, 0x0495F, 0x04D19, 0x050D0, 0x05483, 0x05834, 0x05BE1, 0x05F8B, 0x06332, 0x066D6, 0x06A77, 0x06E15, 0x071B0, 0x07549,
	0x078DE, 0x07C70, 0x08000, 0x0838D, 0x08717, 0x08A9E, 0x08E23, 0x091A5, 0x09524, 0x098A0, 0x09C1A, 0x09F91, 0x0A306, 0x0A678, 0x0A9E8, 0x0AD55,
	0x0B0BF, 0x0B427, 0x0B78D, 0x0BAF0, 0x0BE51, 0x0C1AF, 0x0C50B, 0x0C864, 0x0CBBC, 0x0CF11, 0x0D263, 0x0D5B3, 0x0D902, 0x0DC4D, 0x0DF97, 0x0E2DE,
	0x0E624, 0x0E967, 0x0ECA7, 0x0EFE6, 0x0F323, 0x0F65D, 0x0F995, 0x0FCCC, 0x10000, 0x10332, 0x10662, 0x10990, 0x10CBD, 0x10FE7, 0x1130F, 0x11635,
	0x11959, 0x11C7C, 0x11F9C, 0x122BB, 0x125D7, 0x128F2, 0x12C0B, 0x12F22, 0x13237, 0x1354A, 0x1385C, 0x13B6C, 0x13E7A, 0x14186, 0x14490, 0x14799,
	0x14AA0, 0x14DA5, 0x150A9, 0x153AA, 0x156AB, 0x159A9, 0x15CA6, 0x15FA1, 0x1629A, 0x16592, 0x16888, 0x16B7D, 0x16E70, 0x17161, 0x17451, 0x1773F,
	0x17A2B, 0x17D17, 0x18000, 0x182E8, 0x185CE, 0x188B3, 0x18B97, 0x18E79, 0x19159, 0x19438, 0x19715, 0x199F1, 0x19CCC, 0x19FA5, 0x1A27D, 0x1A553

};

unsigned int SQRT(unsigned int x) {
	int exponent, xfrH, xfrL;//,fraction;
							 //float temp,temp1,temp2;
							 //float atemp, ytemp;
	int y1, a;
	int aaddr;
	int temp3, temp4, temp5;
	int exp1, out;
	//int car;
	exponent = ((x & 0x7e0000) >> 17);
	exp1 = ((x & 0x7e0000) >> 17);
	xfrH = x & 0x1fc00;
	xfrL = x & 0x3ff;
	aaddr = ((x & 0x3fc00) >> 10);
	exponent = exponent - 31;

	a = 0x20000 | SQRTALUT[aaddr];  //1.17
	y1 = 0x40000 | SQRTYLUT[aaddr]; //1.17
	temp5 = (a * xfrL);
	if ((exponent & 1) == 0) {
		temp3 = temp5 >> 18;
	}
	else {
		temp3 = temp5 >> 17;
	}

	temp4 = y1 + temp3;
	temp4 = temp4 >> 1;
	exponent = exponent >> 1;
	exponent = exponent + 31 + (temp4 >> 18);
	if (exp1 == 0)
		out = 0;
	else out = (exponent << 17) | (temp4 & 0x1ffff);
	return out;
}

int SinCosAExpLUT[256] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,
						  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
						  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
						  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
						  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x03,
						  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03 };
int SinCosAFractionLUT[256] = { 0x1fffe,0x1fff4,0x1ffe0,0x1ffc3,0x1ff9b,0x1ff6a,0x1ff2f,0x1feea,0x1fe9b,0x1fe42,0x1fddf,0x1fd73,0x1fcfc,0x1fc7c,0x1fbf2,0x1fb5e,
							   0x1fac1,0x1fa19,0x1f968,0x1f8ad,0x1f7e8,0x1f719,0x1f641,0x1f55f,0x1f473,0x1f37d,0x1f27d,0x1f174,0x1f061,0x1ef44,0x1ee1e,0x1ecee,
							   0x1ebb4,0x1ea70,0x1e923,0x1e7cd,0x1e66c,0x1e502,0x1e38e,0x1e211,0x1e08a,0x1defa,0x1dd60,0x1dbbd,0x1da10,0x1d859,0x1d699,0x1d4d0,
							   0x1d2fd,0x1d120,0x1cf3b,0x1cd4b,0x1cb53,0x1c951,0x1c746,0x1c531,0x1c313,0x1c0ec,0x1bebc,0x1bc82,0x1ba3f,0x1b7f3,0x1b59e,0x1b33f,
							   0x1b0d8,0x1ae67,0x1abed,0x1a96b,0x1a6df,0x1a44a,0x1a1ac,0x19f05,0x19c56,0x1999d,0x196db,0x19411,0x1913e,0x18e62,0x18b7d,0x18890,
							   0x18599,0x1829a,0x17f93,0x17c83,0x1796a,0x17648,0x1731e,0x16fec,0x16cb1,0x1696e,0x16622,0x162ce,0x15f71,0x15c0c,0x1589f,0x1552a,
							   0x151ac,0x14e26,0x14a98,0x14702,0x14364,0x13fbe,0x13c10,0x13859,0x1349b,0x130d5,0x12d07,0x12931,0x12554,0x1216e,0x11d81,0x1198c,
							   0x11590,0x1118c,0x10d80,0x1096d,0x10553,0x10131,0x0fd07,0x0f8d6,0x0f49e,0x0f05f,0x0ec18,0x0e7ca,0x0e375,0x0df19,0x0dab5,0x0d64b,
							   0x0d1d9,0x0cd61,0x0c8e2,0x0c45c,0x0bfcf,0x0bb3b,0x0b6a1,0x0b1ff,0x0ad58,0x0a8a9,0x0a3f4,0x09f39,0x09a77,0x095ae,0x090e0,0x08c0b,
							   0x0872f,0x0824e,0x07d66,0x07878,0x07384,0x06e8a,0x0698a,0x06484,0x05f78,0x05a66,0x0554e,0x05031,0x04b0e,0x045e5,0x040b7,0x03b83,
							   0x03649,0x0310a,0x02bc6,0x0267d,0x0212e,0x01bd9,0x01680,0x01121,0x00bbe,0x00655,0x000e7,0x1f6ea,0x1ebfb,0x1e102,0x1d600,0x1caf4,
							   0x1bfdf,0x1b4c1,0x1a999,0x19e69,0x1932f,0x187ed,0x17ca2,0x1714e,0x165f2,0x15a8e,0x14f21,0x143ac,0x1382f,0x12caa,0x1211d,0x11589,
							   0x109ed,0x0fe49,0x0f29e,0x0e6ec,0x0db32,0x0cf72,0x0c3aa,0x0b7dc,0x0ac07,0x0a02c,0x0944a,0x08861,0x07c73,0x0707e,0x06483,0x05883,
							   0x04c7c,0x04070,0x0345e,0x02847,0x01c2b,0x01009,0x003e2,0x1ef6e,0x1d70d,0x1bea2,0x1a62e,0x18db1,0x1752c,0x15c9d,0x14407,0x12b68,
							   0x112c2,0x0fa14,0x0e15f,0x0c8a3,0x0afdf,0x09715,0x07e45,0x0656f,0x04c92,0x033b0,0x01ac9,0x001dc,0x1d1d6,0x19fea,0x16df4,0x13bf6,
							   0x109f0,0x0d7e3,0x0a5ce,0x073b3,0x04192,0x00f6b,0x1dd40,0x1ab0f,0x178db,0x146a3,0x11468,0x0e22a,0x0afea,0x07da8,0x04b65,0x01921 };
int SinCosYExpLUT[256] = { 0x00,0x07,0x06,0x05,0x05,0x05,0x04,0x04,0x04,0x04,0x04,0x03,0x03,0x03,0x03,0x03,
						  0x03,0x03,0x03,0x03,0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
						  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x01,
						  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
						  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
						  0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
int SinCosYFractionLUT[256] = { 0x00000,0x1243e,0x1243a,0x05b26,0x1242a,0x1ed26,0x05b0c,0x0bf80,0x123ec,0x18851,0x1ecad,0x02880,0x05aa4,0x08cc2,0x0beda,0x0f0eb,
							   0x122f4,0x154f6,0x186f0,0x1b8e1,0x1eac9,0x00e54,0x0273e,0x04022,0x05902,0x071db,0x08aae,0x0a37b,0x0bc42,0x0d502,0x0edbb,0x1066c,
							   0x11f17,0x137b9,0x15054,0x168e6,0x18170,0x199f1,0x1b269,0x1cad9,0x1e33f,0x1fb9b,0x009f7,0x0161b,0x0223a,0x02e54,0x03a68,0x04677,
							   0x05280,0x05e84,0x06a82,0x07679,0x0826b,0x08e57,0x09a3c,0x0a61b,0x0b1f3,0x0bdc4,0x0c98f,0x0d553,0x0e110,0x0ecc6,0x0f875,0x1041c,
							   0x10fbc,0x11b54,0x126e5,0x1326e,0x13def,0x14968,0x154d9,0x16041,0x16ba2,0x176f9,0x18249,0x18d8f,0x198cd,0x1a402,0x1af2e,0x1ba51,
							   0x1c56b,0x1d07c,0x1db83,0x1e680,0x1f174,0x1fc5e,0x0039f,0x0090a,0x00e70,0x013d2,0x0192e,0x01e84,0x023d6,0x02922,0x02e69,0x033ab,
							   0x038e7,0x03e1e,0x0434f,0x0487a,0x04da0,0x052c0,0x057db,0x05cf0,0x061ff,0x06708,0x06c0b,0x07108,0x075ff,0x07af0,0x07fdb,0x084bf,
							   0x0899e,0x08e76,0x09348,0x09814,0x09cd9,0x0a198,0x0a650,0x0ab02,0x0afad,0x0b451,0x0b8ef,0x0bd86,0x0c216,0x0c6a0,0x0cb23,0x0cf9e,
							   0x0d413,0x0d881,0x0dce8,0x0e148,0x0e5a1,0x0e9f2,0x0ee3c,0x0f280,0x0f6bb,0x0faf0,0x0ff1d,0x10343,0x10761,0x10b78,0x10f88,0x1138f,
							   0x11790,0x11b88,0x11f79,0x12362,0x12744,0x12b1d,0x12eef,0x132b9,0x1367c,0x13a36,0x13de8,0x14192,0x14534,0x148cf,0x14c61,0x14feb,
							   0x1536c,0x156e6,0x15a57,0x15dc0,0x16121,0x16479,0x167c9,0x16b11,0x16e50,0x17187,0x174b5,0x177da,0x17af8,0x17e0c,0x18118,0x1841b,
							   0x18716,0x18a08,0x18cf1,0x18fd1,0x192a9,0x19578,0x1983e,0x19afb,0x19daf,0x1a05a,0x1a2fc,0x1a596,0x1a826,0x1aaad,0x1ad2c,0x1afa1,
							   0x1b20d,0x1b470,0x1b6ca,0x1b91a,0x1bb62,0x1bda0,0x1bfd5,0x1c201,0x1c424,0x1c63d,0x1c84d,0x1ca53,0x1cc51,0x1ce44,0x1d02f,0x1d210,
							   0x1d3e8,0x1d5b6,0x1d77b,0x1d936,0x1dae8,0x1dc90,0x1de2f,0x1dfc4,0x1e14f,0x1e2d1,0x1e44a,0x1e5b9,0x1e71e,0x1e87a,0x1e9cc,0x1eb14,
							   0x1ec52,0x1ed87,0x1eeb3,0x1efd4,0x1f0ec,0x1f1fa,0x1f2ff,0x1f3f9,0x1f4ea,0x1f5d1,0x1f6af,0x1f782,0x1f84c,0x1f90c,0x1f9c2,0x1fa6f,
							   0x1fb11,0x1fbaa,0x1fc39,0x1fcbe,0x1fd39,0x1fdab,0x1fe12,0x1fe70,0x1fec4,0x1ff0e,0x1ff4e,0x1ff84,0x1ffb1,0x1ffd3,0x1ffec,0x1fffb };
unsigned int SINCOS(unsigned int x, unsigned int mode) {
	int sign, exp, ifraction;
	int fixed_fraction, fraction;
	unsigned int out;
	unsigned int AExp, AFraction, YExp, YFraction, AX, XFraction, XSign, AXShift, AXShiftValue;
	unsigned int OutFraction;
	unsigned int ExpCompute, FractionCompute;
	unsigned int AAddr, YAddr;
	static unsigned int AXShiftMax = 0;
	unsigned int fixed_int;
	unsigned int One, Zero;
	sign = x >> 23;
	exp = (x >> 17) & 0x3f;

	ifraction = (exp == 0) ? 0 : (x & 0x1FFFF) + 0x20000;
	if (exp > 0x1f)
		fixed_fraction = ifraction << (exp - 0x1f);
	else
		fixed_fraction = ifraction >> (0x1f - exp);
	fixed_int = fixed_fraction >> 17;
	fixed_fraction = fixed_fraction & 0x1ffff;
	fixed_int = fixed_int & 3;

	One = 0;
	Zero = 0;
	if (mode == 1) {
		if (fixed_int == 0) {
			fraction = 0x20000 - fixed_fraction;
			sign = 0;
			if (fraction & 0x20000)
				One = 1;
		}
		else if (fixed_int == 1) {
			fraction = fixed_fraction;
			sign = 1;
		}
		else if (fixed_int == 2) {
			fraction = 0x20000 - fixed_fraction;
			sign = 1;
			if (fraction & 0x20000)
				One = 1;
		}
		else if (fixed_int == 3) {
			fraction = fixed_fraction;
			sign = 0;
		}
	}
	else {
		if (fixed_int == 0) {
			fraction = fixed_fraction;
			sign = sign;
		}
		else if (fixed_int == 1) {
			fraction = 0x20000 - fixed_fraction;
			sign = sign;
			if (fraction & 0x20000)
				One = 1;
		}
		else if (fixed_int == 2) {
			fraction = fixed_fraction;
			sign = ((~sign) & 1);
		}
		else if (fixed_int == 3) {
			fraction = 0x20000 - fixed_fraction;
			sign = ((~sign) & 1);
			if (fraction & 0x20000)
				One = 1;
		}
	}

	AAddr = (fraction >> 9) & 0xFF;
	//if (AAddr == 0xFF)
	//	XSign = 0;
	//else 
	XSign = ((fraction >> 8) & 1);
	YAddr = ((fraction >> 9) & 0xFF) + XSign;
	XFraction = fraction & 0xFF;
	if (XSign)
		XFraction = (~XFraction) & 0xFF;

	AExp = SinCosAExpLUT[AAddr];
	AFraction = SinCosAFractionLUT[AAddr];
	if (AAddr < 0xF6)
		AFraction += 0x20000;
	YExp = SinCosYExpLUT[YAddr & 0xFF];
	if (YAddr == 0x100)
		YExp = -1;
	YFraction = SinCosYFractionLUT[YAddr & 0xFF];
	YFraction += 0x20000;

	AX = AFraction * XFraction;
	AXShiftValue = 17 + (AExp - YExp);
	AXShift = AX >> AXShiftValue;

	if (AXShift > AXShiftMax)
		AXShiftMax = AXShift;
	if (YAddr == 0) {
		OutFraction = AX;
		YExp = AExp + 17;
	}
	else if (XSign)
		OutFraction = YFraction - AXShift;
	else
		OutFraction = YFraction + AXShift;
	YExp++;
	if (OutFraction & (0xF8000000)) {
		printf("test");
		ExpCompute = 0x1f - YExp + 1;
		FractionCompute = (OutFraction >> 1) & 0x1FFFF;
	}
	else if (OutFraction & (0x4000000)) {
		ExpCompute = 0x1f - YExp + 9;
		FractionCompute = (OutFraction >> 9) & 0x1FFFF;
	}
	else if (OutFraction & (0x2000000)) {
		ExpCompute = 0x1f - YExp + 8;
		FractionCompute = (OutFraction >> 8) & 0x1FFFF;
	}
	else if (OutFraction & (0x1000000)) {
		ExpCompute = 0x1f - YExp + 7;
		FractionCompute = (OutFraction >> 7) & 0x1FFFF;
	}
	else if (OutFraction & (0x800000)) {
		ExpCompute = 0x1f - YExp + 6;
		FractionCompute = (OutFraction >> 6) & 0x1FFFF;
	}
	else if (OutFraction & (0x400000)) {
		ExpCompute = 0x1f - YExp + 5;
		FractionCompute = (OutFraction >> 5) & 0x1FFFF;
	}
	else if (OutFraction & (0x200000)) {
		ExpCompute = 0x1f - YExp + 4;
		FractionCompute = (OutFraction >> 4) & 0x1FFFF;
	}
	else if (OutFraction & (0x100000)) {
		ExpCompute = 0x1f - YExp + 3;
		FractionCompute = (OutFraction >> 3) & 0x1FFFF;
	}
	else if (OutFraction & (0x80000)) {
		ExpCompute = 0x1f - YExp + 2;
		FractionCompute = (OutFraction >> 2) & 0x1FFFF;
	}
	else if (OutFraction & 0x40000) {
		ExpCompute = 0x1f - YExp + 1;
		FractionCompute = (OutFraction >> 1) & 0x1FFFF;
	}
	else if (OutFraction & 0x20000) {
		ExpCompute = 0x1f - YExp;
		FractionCompute = OutFraction & 0x1FFFF;
	}
	else if (OutFraction & 0x10000) {
		ExpCompute = 0x1f - YExp - 1;
		FractionCompute = (OutFraction << 1) & 0x1FFFF;
	}
	else if (OutFraction & 0x8000) {
		ExpCompute = 0x1f - YExp - 2;
		FractionCompute = (OutFraction << 2) & 0x1FFFF;
	}
	else if (OutFraction & 0x4000) {
		ExpCompute = 0x1f - YExp - 3;
		FractionCompute = (OutFraction << 3) & 0x1FFFF;
	}
	else if (OutFraction & 0x2000) {
		ExpCompute = 0x1f - YExp - 4;
		FractionCompute = (OutFraction << 4) & 0x1FFFF;
	}
	else if (OutFraction & 0x1000) {
		ExpCompute = 0x1f - YExp - 5;
		FractionCompute = (OutFraction << 5) & 0x1FFFF;
	}
	else if (OutFraction & 0x800) {
		ExpCompute = 0x1f - YExp - 6;
		FractionCompute = (OutFraction << 6) & 0x1FFFF;
	}
	else if (OutFraction & 0x400) {
		ExpCompute = 0x1f - YExp - 7;
		FractionCompute = (OutFraction << 7) & 0x1FFFF;
	}
	else if (OutFraction & 0x200) {
		ExpCompute = 0x1f - YExp - 8;
		FractionCompute = (OutFraction << 8) & 0x1FFFF;
	}
	else if (OutFraction & 0x100) {
		ExpCompute = 0x1f - YExp - 9;
		FractionCompute = (OutFraction << 9) & 0x1FFFF;
	}
	else if (OutFraction & 0x80) {
		ExpCompute = 0x1f - YExp - 10;
		FractionCompute = (OutFraction << 10) & 0x1FFFF;
	}
	else if (OutFraction & 0x40) {
		ExpCompute = 0x1f - YExp - 11;
		FractionCompute = (OutFraction << 11) & 0x1FFFF;
	}
	else if (OutFraction & 0x20) {
		ExpCompute = 0x1f - YExp - 12;
		FractionCompute = (OutFraction << 12) & 0x1FFFF;
	}
	else if (OutFraction & 0x10) {
		ExpCompute = 0x1f - YExp - 13;
		FractionCompute = (OutFraction << 13) & 0x1FFFF;
	}
	else if (OutFraction & 0x8) {
		ExpCompute = 0x1f - YExp - 14;
		FractionCompute = (OutFraction << 14) & 0x1FFFF;
	}
	else if (OutFraction & 0x4) {
		ExpCompute = 0x1f - YExp - 15;
		FractionCompute = (OutFraction << 15) & 0x1FFFF;
	}
	else if (OutFraction & 0x2) {
		ExpCompute = 0x1f - YExp - 16;
		FractionCompute = (OutFraction << 16) & 0x1FFFF;
	}
	else if (OutFraction & 0x1) {
		ExpCompute = 0x1f - YExp - 17;
		FractionCompute = (OutFraction << 17) & 0x1FFFF;
	}
	else if (OutFraction == 0) {
		ExpCompute = 0;
		FractionCompute = 0;
	}
	else
		printf("test1");

	if (One)
		out = (sign << 23) | 0x3e0000;
	else if (Zero)
		out = 0;
	else
		out = (sign << 23) | (ExpCompute << 17) | FractionCompute;

	return out;
}

// Sign : 1, Exponent : 6, Mantissa : 17, Total : 24 bit
unsigned int FAdder(unsigned int x, unsigned int y, unsigned int mode) {
	int det_add_sub;
	int great_value, sign_l, exp_l, exp_s;
	int frac_l, frac_s, exp_diff, align_s, xor_l, adder0;
	int pre_frac, final_sign, shift_exp, frac_normal, exp_compute, frac_compute, out;
	int xfraction, yfraction;
	int xexp, yexp;

	det_add_sub = (x >> 23) ^ (y >> 23);
	det_add_sub = (det_add_sub & 1);
	det_add_sub = det_add_sub ^ mode;

	// 크기 비교 : {Exp1 + Man1} <> {Exp2 + Man2}
	great_value = ((x & 0x7FFFFF) < (y & 0x7FFFFF)) ? 1 : 0;

	xexp = (x >> 17) & 0x3F;
	yexp = (y >> 17) & 0x3F;

	// Exp가 0이면, 0으로
	if (xexp == 0) xfraction = 0;
	else xfraction = (x & 0x1FFFF) | 0x20000;  // Hidden 1-bit 추가
	if (yexp == 0) yfraction = 0;
	else yfraction = (y & 0x1FFFF) | 0x20000;  // Hidden 1-bit 추가

	sign_l = (great_value) ? (y >> 23) ^ mode : (x >> 23);

	// 큰 값을 large, 작은 값을 small 로 할당
	if (great_value) {
		exp_l = yexp;
		exp_s = xexp;
		frac_l = yfraction;
		frac_s = xfraction;
	}
	else {
		exp_l = xexp;
		exp_s = yexp;
		frac_l = xfraction;
		frac_s = yfraction;
	}

	// Exp 차이 계산
	exp_diff = (exp_l - exp_s) & 0x3F;

	// if ((exp_diff < 20) && (exp_diff > 0))
	if ((0 < exp_diff) && (exp_diff < 20))
		align_s = ((frac_s >> (exp_diff - 1)) & 0x3FFFF);
	else if (exp_diff == 0)
		align_s = frac_s << 1;
	else align_s = 0;

	if (det_add_sub)
		xor_l = (~(frac_l << 1)) & 0xFFFFF;
	else xor_l = (frac_l << 1) & 0xFFFFF;

	adder0 = (align_s + xor_l) & 0xFFFFF;

	if (det_add_sub)
		pre_frac = (~adder0) & 0xFFFFF;
	else pre_frac = adder0;

	final_sign = sign_l;

	if (pre_frac & 0x80000)
		shift_exp = 0;
	else if (pre_frac & 0x40000)
		shift_exp = 1;
	else if (pre_frac & 0x20000)
		shift_exp = 2;
	else if (pre_frac & 0x10000)
		shift_exp = 3;
	else if (pre_frac & 0x8000)
		shift_exp = 4;
	else if (pre_frac & 0x4000)
		shift_exp = 5;
	else if (pre_frac & 0x2000)
		shift_exp = 6;
	else if (pre_frac & 0x1000)
		shift_exp = 7;
	else if (pre_frac & 0x800)
		shift_exp = 8;
	else if (pre_frac & 0x400)
		shift_exp = 9;
	else if (pre_frac & 0x200)
		shift_exp = 10;
	else if (pre_frac & 0x100)
		shift_exp = 11;
	else if (pre_frac & 0x80)
		shift_exp = 12;
	else if (pre_frac & 0x40)
		shift_exp = 13;
	else if (pre_frac & 0x20)
		shift_exp = 14;
	else if (pre_frac & 0x10)
		shift_exp = 15;
	else if (pre_frac & 0x8)
		shift_exp = 16;
	else if (pre_frac & 0x4)
		shift_exp = 17;
	else if (pre_frac & 0x2)
		shift_exp = 18;
	else shift_exp = 19;

	frac_normal = (pre_frac << shift_exp) & 0x7FFFF;

	exp_compute = (exp_l - shift_exp + 1) & 0xFF;

	frac_compute = (frac_normal >> 2) & 0x1FFFF;

	if (pre_frac == 0 || exp_compute == 0)
		out = 0;
	else if (exp_compute & 0x80)
		out = 0;
	else if (exp_compute & 0x40)
		out = (final_sign << 23) | 0x7FFFFF;
	else out = (final_sign << 23) | (exp_compute << 17) | frac_compute;

#ifdef OPDebug
	{
		float fx, fy, fout;
		int outtemp;
		fx = f24f32(x);
		fy = f24f32(y);
		fout = (mode) ? fx - fy : fx + fy;
		outtemp = (int)x_f32f24(fout) - out;
		if (outtemp > 1 || outtemp < -1) {
			printf("FAdderError : x = %x, y = %x, mode = %d, out = %x\n", x, y, mode, out);
		}
	}
#endif	
	return out;
}

unsigned int TFAdder(unsigned int x, unsigned int y, unsigned int z) {
	int sfX, sfY, sfZ;
	int xydiff, xzdiff, yzdiff;
	int f_l, f_s1, f_s2, exp_l, exp_s1, exp_s2;
	int exp_diff1, exp_diff2;
	int fr_n1, fr_n2;
	int Sign_s1, Sign_s2;
	int addition, final_sign;
	int pre_frac, shift_exp;
	int frac_normal, exp_compute, frac_compute, out;



	if ((x & 0x7E0000) == 0)
		sfX = 0;
	else if ((x & 0x800000) == 0)
		sfX = ((x & 0x1FFFF) | 0x20000) * 4;
	else {
		sfX = ((x & 0x1FFFF) | 0x20000) * 4;
		sfX = -sfX;
	}

	if ((y & 0x7E0000) == 0)
		sfY = 0;
	else if ((y & 0x800000) == 0)
		sfY = ((y & 0x1FFFF) | 0x20000) * 4;
	else {
		sfY = ((y & 0x1FFFF) | 0x20000) * 4;
		sfY = -sfY;
	}

	if ((z & 0x7E0000) == 0)
		sfZ = 0;
	else if ((z & 0x800000) == 0)
		sfZ = ((z & 0x1FFFF) | 0x20000) * 4;
	else {
		sfZ = ((z & 0x1FFFF) | 0x20000) * 4;
		sfZ = -sfZ;
	}


	xydiff = (x & 0x7E0000) - (y & 0x7E0000);
	xzdiff = (x & 0x7E0000) - (z & 0x7E0000);
	yzdiff = (y & 0x7E0000) - (z & 0x7E0000);

	if (xydiff >= 0) {
		if (xzdiff >= 0) {
			f_l = sfX;
			exp_l = ((x & 0x7E0000) >> 17);
			f_s1 = sfY;
			exp_s1 = ((y & 0x7E0000) >> 17);
			f_s2 = sfZ;
			exp_s2 = ((z & 0x7E0000) >> 17);
			Sign_s1 = ((y >> 23) & 1);
			Sign_s2 = ((z >> 23) & 1);
		}
		else {
			f_l = sfZ;
			exp_l = ((z & 0x7E0000) >> 17);
			f_s1 = sfX;
			exp_s1 = ((x & 0x7E0000) >> 17);
			f_s2 = sfY;
			exp_s2 = ((y & 0x7E0000) >> 17);
			Sign_s1 = ((x >> 23) & 1);
			Sign_s2 = ((y >> 23) & 1);
		}
	}
	else if (yzdiff >= 0) {
		f_l = sfY;
		exp_l = ((y & 0x7E0000) >> 17);
		f_s1 = sfZ;
		exp_s1 = ((z & 0x7E0000) >> 17);
		f_s2 = sfX;
		exp_s2 = ((x & 0x7E0000) >> 17);
		Sign_s1 = ((z >> 23) & 1);
		Sign_s2 = ((x >> 23) & 1);
	}
	else {
		f_l = sfZ;
		exp_l = ((z & 0x7E0000) >> 17);
		f_s1 = sfY;
		exp_s1 = ((y & 0x7E0000) >> 17);
		f_s2 = sfX;
		exp_s2 = ((x & 0x7E0000) >> 17);
		Sign_s1 = ((y >> 23) & 1);
		Sign_s2 = ((x >> 23) & 1);
	}


	exp_diff1 = exp_l - exp_s1;
	exp_diff2 = exp_l - exp_s2;

	if (exp_diff1 <= 20) {
		if (Sign_s1)
			fr_n1 = -((-f_s1) >> exp_diff1);
		else
			fr_n1 = f_s1 >> exp_diff1;
	}
	else fr_n1 = 0;

	if (exp_diff2 <= 20)
		if (Sign_s2)
			fr_n2 = -((-f_s2) >> exp_diff2);
		else
			fr_n2 = f_s2 >> exp_diff2;
	else fr_n2 = 0;


	addition = f_l + fr_n1 + fr_n2;
	if (addition < 0)
		final_sign = 1;
	else final_sign = 0;

	if (addition < 0)
		pre_frac = (-addition);
	else pre_frac = addition;


	if (pre_frac & 0x200000)
		shift_exp = 0;
	else if (pre_frac & 0x100000)
		shift_exp = 1;
	else if (pre_frac & 0x80000)
		shift_exp = 2;
	else if (pre_frac & 0x40000)
		shift_exp = 3;
	else if (pre_frac & 0x20000)
		shift_exp = 4;
	else if (pre_frac & 0x10000)
		shift_exp = 5;
	else if (pre_frac & 0x8000)
		shift_exp = 6;
	else if (pre_frac & 0x4000)
		shift_exp = 7;
	else if (pre_frac & 0x2000)
		shift_exp = 8;
	else if (pre_frac & 0x1000)
		shift_exp = 9;
	else if (pre_frac & 0x800)
		shift_exp = 10;
	else if (pre_frac & 0x400)
		shift_exp = 11;
	else if (pre_frac & 0x200)
		shift_exp = 12;
	else if (pre_frac & 0x100)
		shift_exp = 13;
	else if (pre_frac & 0x80)
		shift_exp = 14;
	else if (pre_frac & 0x40)
		shift_exp = 15;
	else if (pre_frac & 0x20)
		shift_exp = 16;
	else if (pre_frac & 0x10)
		shift_exp = 17;
	else if (pre_frac & 0x8)
		shift_exp = 18;
	else if (pre_frac & 0x4)
		shift_exp = 19;
	else if (pre_frac & 0x2)
		shift_exp = 20;
	else shift_exp = 21;


	frac_normal = (pre_frac << shift_exp) & 0x1FFFFF;

	exp_compute = (exp_l - shift_exp + 2) & 0xFF;

	frac_compute = (frac_normal >> 4) & 0x1FFFF;

	if (pre_frac == 0 || exp_compute == 0)
		out = 0;
	else if (exp_compute & 0x80)
		out = 0;
	else if (exp_compute & 0x40)
		out = (final_sign << 23) | 0x7FFFFF;
	else out = (final_sign << 23) | (exp_compute << 17) | frac_compute;

#ifdef OPDebug
	{
		float fx, fy, fz, fout;
		int outtemp, ErrorValue;
		fx = f24f32(x);
		fy = f24f32(y);
		fz = f24f32(z);
		fout = fx + fy + fz;
		outtemp = (int)x_f32f24(fout) - out;
		if (outtemp > 2 || outtemp < -2) {
			if (out == 0) {
				if ((exp_l - ((outtemp >> 17) & 0x3f)) > (shift_exp + 1))
					printf("TAdderError : x = %x, y = %x, z = %x, out = %x\n", x, y, z, out);
			}
			else if ((shift_exp - 4) <= 0)
				printf("TAdderError : x = %x, y = %x, z = %x, out = %x\n", x, y, z, out);
			else {
				ErrorValue = 2 << (shift_exp - 4);
				if (outtemp > ErrorValue || outtemp < -ErrorValue)
					printf("TAdderError : x = %x, y = %x, z = %x, out = %x\n", x, y, z, out);
			}
		}
	}
#endif

	return out;
}

unsigned int Compare(unsigned int x, unsigned int y) {
	float fx, fy;
	fx = f24f32(x);
	fy = f24f32(y);
	if (fx > fy)
		return 1;
	else if (fy > fx)
		return 2;
	else
		return 0;
}

unsigned int SIN(unsigned int x) {
	return SINCOS(x, 0);
}
unsigned int COS(unsigned int x) {
	return SINCOS(x, 1);
}
unsigned int UFAdder(unsigned int x, unsigned int y) {
	return FAdder(x, y, 0);
}
unsigned int UTFAdder(unsigned int x, unsigned int y, unsigned int z) {
	return TFAdder(x, y, z);
}


/////////////////ACOS(X)/PI
unsigned int ACOS_Y0[192] = {
	0x10000,0xfeba,0xfd74,0xfc2e,0xfae7,0xf9a1,0xf85b,0xf715,0xf5ce,0xf488,0xf341,0xf1fa,0xf0b2,0xef6b,0xee23,0xecdb,
	0xeb93,0xea4a,0xe901,0xe7b7,0xe66e,0xe523,0xe3d9,0xe28e,0xe142,0xdff6,0xdea9,0xdd5c,0xdc0f,0xdac0,0xd971,0xd822,
	0xd6d1,0xd580,0xd42f,0xd2dc,0xd189,0xd035,0xcee0,0xcd8a,0xcc33,0xcadc,0xc983,0xc82a,0xc6cf,0xc573,0xc417,0xc2b9,
	0xc15a,0xbffa,0xbe98,0xbd35,0xbbd1,0xba6c,0xb905,0xb79d,0xb633,0xb4c8,0xb35b,0xb1ed,0xb07d,0xaf0b,0xad97,0xac22,
	0xaaaa,0xa931,0xa7b5,0xa638,0xa4b8,0xa336,0xa1b2,0xa02c,0x9ea3,0x9d17,0x9b89,0x99f8,0x9865,0x96ce,0x9535,0x9398,
	0x91f8,0x9055,0x8eae,0x8d04,0x8b56,0x89a4,0x87ee,0x8633,0x8475,0x82b2,0x80ea,0x7f1d,0x7d4b,0x7b73,0x7996,0x77b3,
	0x75c9,0x73d9,0x71e2,0x6fe3,0x6ddd,0x6bcf,0x69b8,0x6798,0x656e,0x6339,0x60fa,0x5eae,0x5c55,0x59ef,0x577a,0x54f4,
	0x525c,0x4fb0,0x4cef,0x4a16,0x4722,0x440f,0x40d9,0x3d7a,0x39ec,0x3625,0x3218,0x2db3,0x28d9,0x235a,0x1cd9,0x1462,

	0x1462,0x1439,0x1410,0x13e6,0x13bc,0x1392,0x1367,0x133c,0x1311,0x12e5,0x12b9,0x128c,0x125f,0x1231,0x1203,0x11d5,
	0x11a6,0x1177,0x1147,0x1117,0x10e6,0x10b4,0x1082,0x104f,0x101c,0xfe8,0xfb4,0xf7e,0xf48,0xf12,0xeda,0xea2,
	0xe68,0xe2e,0xdf3,0xdb7,0xd7a,0xd3c,0xcfc,0xcbc,0xc7a,0xc37,0xbf2,0xbac,0xb63,0xb1a,0xace,0xa80,
	0xa30,0x9dd,0x987,0x92e,0x8d2,0x872,0x80d,0x7a3,0x733,0x6bc,0x63c,0x5b1,0x517,0x469,0x399,0x28b
};

unsigned int ACOS_A0[192] = {
	0x00a2fa,0x00a2fc,0x00a301,0x00a309,0x00a314,0x00a320,0x00a32f,0x00a341,0x00a356,0x00a36d,0x00a386,0x00a3a3,0x00a3c2,0x00a3e4,0x00a407,0x00a42e,
	0x00a459,0x00a485,0x00a4b4,0x00a4e6,0x00a51b,0x00a553,0x00a58d,0x00a5cb,0x00a60c,0x00a64f,0x00a695,0x00a6df,0x00a72c,0x00a77b,0x00a7cf,0x00a825,
	0x00a87f,0x00a8dc,0x00a93d,0x00a9a1,0x00aa09,0x00aa74,0x00aae3,0x00ab56,0x00abcd,0x00ac48,0x00acc7,0x00ad4a,0x00add1,0x00ae5c,0x00aeed,0x00af81,
	0x00b01b,0x00b0b9,0x00b15d,0x00b205,0x00b2b3,0x00b365,0x00b41e,0x00b4dc,0x00b5a1,0x00b66a,0x00b73b,0x00b812,0x00b8f0,0x00b9d4,0x00bac1,0x00bbb3,
	0x00bcaf,0x00bdb1,0x00bebc,0x00bfd1,0x00c0ed,0x00c213,0x00c343,0x00c47d,0x00c5c1,0x00c711,0x00c86c,0x00c9d3,0x00cb46,0x00ccc7,0x00ce56,0x00cff2,
	0x00d19f,0x00d35b,0x00d529,0x00d708,0x00d8fa,0x00daff,0x00dd1b,0x00df4c,0x00e196,0x00e3f8,0x00e676,0x00e910,0x00ebc9,0x00eea4,0x00f1a1,0x00f4c5,
	0x00f812,0x00fb8c,0x00ff36,0x010314,0x01072b,0x010b81,0x01101c,0x011502,0x011a3c,0x011fd1,0x0125cf,0x012c40,0x013335,0x013abd,0x0142ee,0x014be1,
	0x0155b6,0x016092,0x016ca7,0x017a30,0x01897f,0x019afd,0x01af3a,0x01c701,0x01e379,0x020663,0x023295,0x026d0a,0x02bf83,0x0340d7,0x043b38,0x0a3148,

	0x51f78,0x529e4,0x53488,0x53f7c,0x54aac,0x5562c,0x561f4,0x56e0c,0x57a78,0x5873c,0x59460,0x5a1dc,0x5afbc,0x5be0c,0x5ccc4,0x5dbf8,
	0x5eb9c,0x5fbc8,0x60c7c,0x61db8,0x62f98,0x6420c,0x65530,0x6690c,0x67da2,0x69304,0x6a944,0x6c068,0x6d88c,0x6f1b4,0x70bfe,0x7277c,
	0x74446,0x76276,0x78232,0x7a38e,0x7c6c0,0x7ebea,0x8133c,0x83cec,0x8694c,0x89890,0x8cb18,0x9014c,0x93ba0,0x97a98,0x9beec,0xa095c,
	0xa5aec,0xab4c4,0xb1870,0xb87e0,0xc058c,0xc94d4,0xd3a38,0xdfc10,0xee3a0,0xffef8,0x1164e0,0x133d38,0x15d638,0x19e6d0,0x21c130,0x517ce0
};
int findAddr(unsigned int input_x) {
	int addr = 0;

	addr = (input_x >> 9) & 0x7f;	//256
	addr = (input_x >> 10) & 0x7f;	//128

	if (addr == 0x7f) { //128+64
		addr = 128 + ((input_x & 0x3ff) >> 4);
	}

	return addr;
}
unsigned int ACOS(unsigned int input_x) {

	int addr;
	int input_sign, input_exp, input_fraction;
	unsigned int fixed_point;
	unsigned int gradient;
	unsigned int y0;
	unsigned int out_temp;
	unsigned int out;
	unsigned int underflow, overflow;

	input_sign = input_x >> 23;
	input_exp = (input_x >> 17) & 0x3f;
	input_fraction = (input_exp == 0) ? 0 : (input_x & 0x1FFFF) + 0x20000;
	fixed_point = input_fraction >> (0x1f - input_exp);

	underflow = (input_exp > 0x1e) ? input_sign : 0;
	overflow = (input_exp > 0x1e) ? (~input_sign) & 1 : 0;
	addr = findAddr(fixed_point);

	gradient = ACOS_A0[addr];
	y0 = ACOS_Y0[addr];

	unsigned int ax_rst;
	unsigned int multiplicand;

	if (addr < 128) multiplicand = (fixed_point & 0x0003ff);
	else multiplicand = (fixed_point & 0x00000f);	//128+64

	ax_rst = (gradient * multiplicand) >> 16;

	unsigned int axb_rst;

	axb_rst = (y0 << 1) - ax_rst;

	if (input_sign) out_temp = 0x040000 - axb_rst;
	else out_temp = axb_rst;

	int rb_exp, out_exp;
	unsigned int out_fraction;

	rb_exp = ((out_temp & 0x03ffff) >> 17) ? 0 :
		((out_temp & 0x03ffff) >> 16) ? 1 :
		((out_temp & 0x03ffff) >> 15) ? 2 :
		((out_temp & 0x03ffff) >> 14) ? 3 :
		((out_temp & 0x03ffff) >> 13) ? 4 :
		((out_temp & 0x03ffff) >> 12) ? 5 :
		((out_temp & 0x03ffff) >> 11) ? 6 :
		((out_temp & 0x03ffff) >> 10) ? 7 :
		((out_temp & 0x03ffff) >> 9) ? 8 :
		((out_temp & 0x03ffff) >> 8) ? 9 :
		((out_temp & 0x03ffff) >> 7) ? 10 :
		((out_temp & 0x03ffff) >> 6) ? 11 :
		((out_temp & 0x03ffff) >> 5) ? 12 :
		((out_temp & 0x03ffff) >> 4) ? 13 :
		((out_temp & 0x03ffff) >> 3) ? 14 :
		((out_temp & 0x03ffff) >> 2) ? 15 :
		((out_temp & 0x03ffff) >> 1) ? 16 : 17;

	out_exp = (0x1f - (1 + rb_exp)) << 17;
	out_fraction = ((out_temp & 0x01ffff) << rb_exp) & 0x01ffff;

	out = underflow ? 0x3e0000 : overflow ? 0 : (out_exp + out_fraction);

	return out;
}



#endif